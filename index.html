<!DOCTYPE html>
<html>
<head>
	<title>[Intimate Spaces]</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, minimal-ui">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="description" content="">
<!--     <meta name="viewport" content="width=device-width, initial-scale=1"> -->
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet">

    <style>
    html, body { margin:0; padding:0; overflow:hidden; font-family: 'Roboto', sans-serif; font-size: 18px;}
    button {
    	margin-left: 20px;
    	width: 100px;
    	height: 30px;
    	font-size: 19px;
    	font-family: 'Roboto', sans-serif;
    	border-radius: 50px;
    	border-color: black;
    }

    button:hover {
    	background-color: #999999; 
	}
    </style>

    <script type="text/javascript">
		var Module = { TOTAL_MEMORY: 1024*1024*100*100*100*100*100*100 }; 
	</script>
    <script src="http://code.jquery.com/jquery-1.11.1.js"></script>
	<script src="lib/three.js"></script>
	<script src="lib/CinematicCamera.js"></script>
	<script src="lib/VRControls.js"></script>
	<script src="lib/VREffect.js"></script>
	<script src="lib/WebVR.js"></script>
	<script src="lib/webvr-polyfill.js"></script>
	<script src="lib/OrbitControls.js"></script>
	<script src="lib/VRController.js"></script>
	<script src="memories.js"></script>
	<script src="lib/ammo.js"></script>
	<script src="lib/WaterRefractionShader.js"></script>
	<script src="lib/Refractor.js"></script>
	

</head>
<body>

	<div id="container">
		<div id="sketch"></div>
		<div id="vr_bb"></div>
	</div>
</body>

<script type="text/javascript">

	// scene setup
	let clock; 
	let container; 
	let renderer;
	let scene; 
	var camera;
	var dollyCam;
	var orbitControls;
	let controls; 
	let lastRenderTime;
	let light;
	let light2; 
	let spheres = [];
	let otherSpheres = [];
	let room;
	let crosshair;
	let x = 1; 
	let y = 1;
	let z = 1; 

	// intersections
	let mouse = new THREE.Vector2(), INTERSECTED;
	let INTERSECTED2;
	let intersects;
	let raycaster = new THREE.Raycaster();
	let arrow;
	//var z; 
	let isBallClicked = false; 

	// VR functionality
	let effect;
	let vrManager; 
	let vrDisplay;
	let vrButton; 
	let vrFrame; 

	// Physics variables
	let collisionConfiguration;
	let dispatcher;
	let broadphase;
	let solver;
	let physicsWorld;
	let dynamicObjects = [];
	let transformAux1 = new Ammo.btTransform();
	let time = 0;

	let frontRefractor;
	let leftRefractor;
	let rightRefractor;
	let bottomRefractor;
	let backRefractor;
	let topRefractor;

	window.addEventListener('load', onLoad);
	container = document.getElementById('container');	

	//onLoading 
	function onLoad() {
		clock = new THREE.Clock(); 
		let wid = window.innerWidth;
		let hei = window.innerHeight;
		let container = document.getElementById('container');

		// INITIALIZATION
		renderer = new THREE.WebGLRenderer({});
		renderer.setPixelRatio(window.devicePixelRatio);
		renderer.setSize(wid, hei);
		container.appendChild( renderer.domElement );

		effect = new THREE.VREffect(renderer);
		effect.setSize(window.innerWidth, window.innerHeight);
		scene  = new THREE.Scene();
		camera = new THREE.PerspectiveCamera(70, wid/hei, 0.1, 1000);

		controls = new THREE.VRControls( camera );
		controls.standing = true;
		controls.update();
		camera.position.y = controls.userHeight;

		dollyCam = new THREE.PerspectiveCamera();
		//dollyCam.position.set(0,20,-50);

		orbitControls = new THREE.OrbitControls(dollyCam);
		dollyCam.add(camera);
		scene.add(dollyCam);

		camera.add( crosshair );
		scene.add(camera);

		arrow = new THREE.ArrowHelper( raycaster.ray.direction, (raycaster.ray.origin), 100, 0xffffff );
		//scene.add( arrow );

		// Initialize (Web)VR
  		renderer.vr.enabled = true;
  		setupVRStage();

  		// EVENTS
  		window.addEventListener('resize', onWindowResize, true );
  		window.addEventListener('vrdisplaypresentchange', onWindowResize, true);
	}

	// sets up the VR stage + button
	function setupVRStage() {
		// get available displays 
		navigator.getVRDisplays().then( function(displays) {
		if(displays.length > 0) {
	  		vrDisplay = displays[0];
	  		// VRStageParameters object containing the VRDisplay's room-scale parameters
	  		if(vrDisplay.stageParameters) {
	    		setStageDimensions(vrDisplay.stageParameters);
	  		}
			controls.update();

		  	// setting up button and onclick function programmed in WEBvr to turn page into VR experience and split screen 
	  		vrButton = WEBVR.getButton( vrDisplay, renderer.domElement );
	  		document.getElementById('vr_bb').appendChild( vrButton );
		} else {
	  		console.log("NO VR DISPLAYS PRESENT");
		}
		initPhysics();
  		createEnvironment();
		update();
		});
	}

	function initPhysics() {
		// Physics configuration
		collisionConfiguration = new Ammo.btDefaultCollisionConfiguration();
		dispatcher = new Ammo.btCollisionDispatcher( collisionConfiguration );
		broadphase = new Ammo.btDbvtBroadphase();
		solver = new Ammo.btSequentialImpulseConstraintSolver();
		physicsWorld = new Ammo.btDiscreteDynamicsWorld( dispatcher, broadphase, solver, collisionConfiguration );
		physicsWorld.setGravity( new Ammo.btVector3( 0, 0, 0 ) );
	}

	// (does nothing for now)
	function setStageDimensions(stage){
  		;
	}

	let boxMesh;

	function createEnvironment() {
		// Lights
		scene.add( new THREE.AmbientLight( 0xffffff, 0.3) );
		//light = new THREE.DirectionalLight( 0x8800ff );
		light = new THREE.DirectionalLight( 0xFAFAFA );
		light.position.set(  - 10, 40,  20 );
		light.castShadow = true;
		light.shadow.camera.zoom = 4;
		scene.add( light );
		light.target.position.set( -6 , 5.5 , 6 );
		scene.add( light.target );

		//light2 = new THREE.DirectionalLight( 0xff0000,2 );
		light2 = new THREE.DirectionalLight( 0xFAFAFA,0.3 );
		light2.position.set( 10, 40, - 20 );
		light2.castShadow = true;
		light2.shadow.camera.zoom = 4;
		scene.add( light2 );
		light2.target.position.set( 6 , 5.5 , -6 );
		scene.add( light2.target );

		// front refractor
		frontRefractor = new THREE.Refractor( 10, 6, {
			color: 0x999999,
			textureWidth: 1024,
			textureHeight: 1024,
			shader: THREE.WaterRefractionShader
		} );
		frontRefractor.position.set( 0,2.5,-5 );
		scene.add( frontRefractor );

		// left refractor
		leftRefractor = new THREE.Refractor( 10, 6, {
			color: 0x999999,
			textureWidth: 1024,
			textureHeight: 1024,
			shader: THREE.WaterRefractionShader

		} );
		leftRefractor.position.set( -5,2.5,0 );
		leftRefractor.rotateY(Math.PI / 2);
		scene.add( leftRefractor );

		// right refractor
		rightRefractor = new THREE.Refractor( 10, 6, {
			color: 0x999999,
			textureWidth: 1024,
			textureHeight: 1024,
			shader: THREE.WaterRefractionShader

		} );
		rightRefractor.position.set( 5,2.5,0 );
		rightRefractor.rotateY(- Math.PI / 2);
		scene.add( rightRefractor );

		// bottom refractor
		bottomRefractor = new THREE.Refractor( 12, 12, {
			color: 0x999999,
			textureWidth: 1024,
			textureHeight: 1024,
			shader: THREE.WaterRefractionShader

		} );
		bottomRefractor.position.set( 0,0,0 );
		bottomRefractor.rotateX( - Math.PI / 2 );
		scene.add( bottomRefractor );

		// back refractor
		backRefractor = new THREE.Refractor( 10, 6, {
			color: 0x999999,
			textureWidth: 1024,
			textureHeight: 1024,
			shader: THREE.WaterRefractionShader

		} );
		backRefractor.position.set( 0,2.5,5 );
		backRefractor.rotateY(  Math.PI );
		scene.add( backRefractor );

		// top refractor
		topRefractor = new THREE.Refractor( 12, 12, {
			color: 0x999999,
			textureWidth: 1024,
			textureHeight: 1024,
			shader: THREE.WaterRefractionShader

		} );
		topRefractor.position.set( 0,4.5,0 );
		topRefractor.rotateX( Math.PI / 2 );
		scene.add( topRefractor );

		// load dudv map for distortion effect
		var dudvMap = new THREE.TextureLoader().load( 'pic/waterdudv.jpg', function () {
			update();
		} );
		dudvMap.wrapS = dudvMap.wrapT = THREE.RepeatWrapping;

		frontRefractor.material.uniforms.tDudv.value = dudvMap;
		leftRefractor.material.uniforms.tDudv.value = dudvMap;
		rightRefractor.material.uniforms.tDudv.value = dudvMap;
		bottomRefractor.material.uniforms.tDudv.value = dudvMap;
		backRefractor.material.uniforms.tDudv.value = dudvMap;
		topRefractor.material.uniforms.tDudv.value = dudvMap;


		let transPlane = new THREE.MeshPhongMaterial({ 
			color: 0x3572B0, 
			shininess: 30,
			metal: true,
			wrapAround: true,
			side:THREE.DoubleSide, 
			transparent: true, 
			opacity: 0.2 
		})

		let solidPlane = new THREE.MeshPhongMaterial({ 
			color: 0x3572B0, 
			shininess: 30,
			metal: true,
			wrapAround: true,
			side:THREE.DoubleSide, 
		})
		
		let bottomPlane = new Plane();
		scene.add(bottomPlane.display(solidPlane,12,12, 0,-0.5,0, Math.PI / 2, 0));

		let leftPlane = new Plane();
		scene.add(leftPlane.display(transPlane,12,6,-6,2.5,0, 0, -Math.PI / 2));

		let rightPlane = new Plane();
		scene.add(rightPlane.display(transPlane,12,6,6,2.5,0, 0, Math.PI / 2));

		let frontPlane = new Plane();
		scene.add(frontPlane.display(transPlane,12,6,0,2.5,6, 0, 0));

		let backPlane = new Plane();
		scene.add(backPlane.display(transPlane,12,6,0,2.5,-6, 0, Math.PI));

		let AbovePlane = new Plane();
		scene.add(AbovePlane.display(transPlane,12,12,0,5.5,0, - Math.PI / 2, 0));

		// Spheres 
		var geometry = new THREE.SphereGeometry( 0.3, 100, 100 );
		var geometry2 = new THREE.SphereGeometry( 0.5, 100, 100 );

		// for (let i=0;i<10;i++) {
		// 	let img = data[i].image; 
		// 	let text = data[i].text;
		// 	let objectSize = 3;
		//     let margin = 0.05;

		// 	let memory = new Memory();
		// 	let object = memory.display(geometry,Math.random() * 4 - 2,Math.random() * 4 - 2,Math.random() * 4 - 2,img,Math.random() * 0.01 - 0.005,0,text);
		// 	//spheres.push(object);
			
		// 	let shape = new Ammo.btSphereShape( 0.3 );
		// 	shape.setMargin( margin );

		// 	let mass = 10000;
		// 	let localInertia = new Ammo.btVector3( 0, 0, 0 );
		// 	shape.calculateLocalInertia( mass, localInertia );
		// 	let transform = new Ammo.btTransform();
		// 	transform.setIdentity();
		// 	let pos = object.position;
		// 	transform.setOrigin( new Ammo.btVector3( pos.x, pos.y, pos.z ) );
		// 	let motionState = new Ammo.btDefaultMotionState( transform );
		// 	let rbInfo = new Ammo.btRigidBodyConstructionInfo( mass, motionState, shape, localInertia );
		// 	let body = new Ammo.btRigidBody( rbInfo );
		// 	//body.setAngularVelocity( new Ammo.btVector3(10,10,10));
		// 	body.setFriction( 1000 );
		// 	object.userData.physicsBody = body;
		// 	object.receiveShadow = true;
		// 	object.castShadow = true;
			
		// 	//scene.add( object );
		// 	//dynamicObjects.push( object );
		// 	//physicsWorld.addRigidBody( body );
		// }

		for ( let i = 0; i < 30; i ++ ) {
			let objectSize = 3;
		    let margin = 0.05;
		    let num = THREE.Math.randInt(0,9);
		    let texture = new THREE.TextureLoader().load( data[num].image );
			texture.format = THREE.RGBFormat;
			//console.log(data[num].colour);
			let materialBack = new THREE.MeshBasicMaterial({ 
		   		map: texture, 
		    	side:THREE.BackSide
			});  

			let materialFront = new THREE.MeshStandardMaterial({ 
			    color: 0x3572B0, 
			    shininess: 30,
			    metal: true,
			    side:THREE.FrontSide
			});

			let materials = [materialFront,materialBack];
			//let object = new THREE.Mesh( geometry2, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff, transparent:true } ) );
			//let object = new THREE.Mesh( geometry2, materials) ;
			let object = THREE.SceneUtils.createMultiMaterialObject( geometry2, materials );
			//console.log(object.children);
			object.position.set(THREE.Math.randInt(-3,3),THREE.Math.randInt(-2,3),THREE.Math.randInt(-3,0));
			
			let shape = new Ammo.btSphereShape( 0.5 );
			shape.setMargin( margin );
			// object.position.x = Math.random() * 4 - 2;
			// object.position.y = Math.random() * 4 - 2;
			// object.position.z = Math.random() * 4 - 2;

			let mass = 0.5 * 2;
			let localInertia = new Ammo.btVector3( 0, 0, 0 );
			shape.calculateLocalInertia( mass, localInertia );
			let transform = new Ammo.btTransform();
			transform.setIdentity();
			let pos = object.position;
			transform.setOrigin( new Ammo.btVector3( pos.x, pos.y, pos.z ) );
			let motionState = new Ammo.btDefaultMotionState( transform );
			let rbInfo = new Ammo.btRigidBodyConstructionInfo( mass, motionState, shape, localInertia );
			let body = new Ammo.btRigidBody( rbInfo );
			//body.setAngularVelocity( new Ammo.btVector3(1,1,1));
			body.setFriction( 200 );
			object.userData.physicsBody = body;
			object.receiveShadow = true;
			object.castShadow = true;

			object.children[0].userData.sister = i;
			object.children[1].userData.sister = i;
			
			scene.add( object );
			dynamicObjects.push( object );
			physicsWorld.addRigidBody( body );

			spheres.push(object.children[0]);
			spheres.push(object.children[1]);

			//spheres.push(object.children[1]);
		}

		// Target Symbol
		let targetMaterial = new THREE.LineBasicMaterial({ color: 0xAAFFAA });

		let x = 0.01, y = 0.01;

		let target = new THREE.Geometry();

		// crosshair
		target.vertices.push(new THREE.Vector3(0, y, 0));
		target.vertices.push(new THREE.Vector3(0, -y, 0));
		target.vertices.push(new THREE.Vector3(0, 0, 0));
		target.vertices.push(new THREE.Vector3(x, 0, 0));    
		target.vertices.push(new THREE.Vector3(-x, 0, 0));

		crosshair = new THREE.Line( target, targetMaterial );

		// place it in the center
		let crosshairPercentX = 50;
		let crosshairPercentY = 50;
		let crosshairPositionX = (crosshairPercentX / 100) * 2 - 1;
		let crosshairPositionY = (crosshairPercentY / 100) * 2 - 1;

		crosshair.position.x = crosshairPositionX * camera.aspect;
		crosshair.position.y = crosshairPositionY;

		crosshair.position.z = -0.3;
		camera.add( crosshair );

		// create skyDome

		// https://www.eso.org/public/usa/images/eso0932a/
		let loader = new THREE.TextureLoader();
		let skyGeo = new THREE.SphereGeometry(500, 25, 25);
		let skyMat = new THREE.MeshPhongMaterial({
			map: loader.load("media/eso0932a_sphere_min.jpg"),
		});
		let skyDome = new THREE.Mesh(skyGeo, skyMat);
		skyDome.material.side = THREE.BackSide;
		scene.add(skyDome);


	}

	function onWindowResize(){
		let wid = window.innerWidth;
	    let hei = window.innerHeight;
	    effect.setSize(wid, hei);
	    renderer.setSize(wid, hei);
		camera.aspect = wid/hei;
	    camera.updateProjectionMatrix();
	    console.log("UPDATE SIZE");
	}

	function onMouseMove( event ) {
		// calculate mouse position in normalized device coordinates
		// (-1 to +1) for both components

		mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
		mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
	}

	function Plane () { 
		this.display = function (material,wid,hei,x,y,z,rotX,rotY) {
			let plane = new THREE.PlaneGeometry( wid, hei, 24 ,24);
			let planeMesh = new THREE.Mesh( plane, material );
			planeMesh.position.set(x,y,z);
			planeMesh.rotateX( rotX );
			planeMesh.rotateY( rotY );

			ground = new Ammo.btStaticPlaneShape( new Ammo.btVector3(0,0,-1),0);

			let mass = 0;
			let localInertia = new Ammo.btVector3( 0, 0, 0 );
			ground.calculateLocalInertia( mass, localInertia );
			let transform = new Ammo.btTransform();
			transform.setIdentity();
			let pos = planeMesh.position;
			transform.setOrigin( new Ammo.btVector3( pos.x, pos.y, pos.z ) );
			let rot = planeMesh.quaternion;
			transform.setRotation(new Ammo.btQuaternion( rot.x , rot.y , rot.z , rot.w ) );
			let motionState = new Ammo.btDefaultMotionState( transform );
			let rbInfo = new Ammo.btRigidBodyConstructionInfo( mass, motionState, ground, localInertia );
			let body = new Ammo.btRigidBody( rbInfo );
			body.setFriction( 0.2 );
			planeMesh.userData.physicsBody = body;
			//planeMesh.receiveShadow = true;
			//planeMesh.castShadow = true;
			physicsWorld.addRigidBody( body );
			
			return planeMesh;
			
		}
	}

	function Memory() {
		this.display = function (geometry,x,y,z,material,velocity,acceleration,text) {
			var texture = new THREE.TextureLoader().load( this.material );
			texture.format = THREE.RGBFormat;

			var material = new THREE.MeshBasicMaterial( { map: texture, side:THREE.DoubleSide } );

			// light inside sphere 
			let light = new THREE.PointLight( 0xff0000, 1, 100 );
			light.position.set( this.x, this.y, this.z );
			//scene.add( light );

			object = new THREE.Mesh(this.geometry, material);
			object.position.x = this.x;
			object.position.y = this.y;
			object.position.z = this.z;

			object.userData.velocity = new THREE.Vector3();
			object.userData.velocity.x = this.velocity;
			object.userData.velocity.y = this.velocity;
			object.userData.velocity.z = this.velocity;

			return object;
		} 
	}

	window.addEventListener( 'vr controller connected', function( event ){
		//  Here it is, your VR controller instance.
		//  It’s really a THREE.Object3D so you can just add it to your scene:
		var controller = event.detail
		scene.add( controller )
		//  HEY HEY HEY! This is important. You need to make sure you do this.
		//  For standing experiences (not seated) we need to set the standingMatrix
		//  otherwise you’ll wonder why your controller appears on the floor
		//  instead of in your hands! And for seated experiences this will have no
		//  effect, so safe to do either way:
		controller.standingMatrix = renderer.vr.getStandingMatrix()
		//  And for 3DOF (seated) controllers you need to set the controller.head
		//  to reference your camera. That way we can make an educated guess where
		//  your hand ought to appear based on the camera’s rotation.
		controller.head = window.camera
		//  Right now your controller has no visual.
		//  It’s just an empty THREE.Object3D.
		//  Let’s fix that!
		var
		meshColorOff = 0xDB3236,//  Red.
		meshColorOn  = 0xF4C20D,//  Yellow.
		controllerMaterial = new THREE.MeshStandardMaterial({
			color: meshColorOff
		}),
		controllerMesh = new THREE.Mesh(
			new THREE.CylinderGeometry( 0.005, 0.05, 0.1, 6 ),
			controllerMaterial
		),
		handleMesh = new THREE.Mesh(
			new THREE.BoxGeometry( 0.03, 0.1, 0.03 ),
			controllerMaterial
		)
		controllerMaterial.flatShading = true
		controllerMesh.rotation.x = -Math.PI / 2
		handleMesh.position.y = -0.05
		controllerMesh.add( handleMesh )
		controller.userData.mesh = controllerMesh//  So we can change the color later.
		controller.add( controllerMesh )

		//  Button events. How easy is this?!
		//  We’ll just use the “primary” button -- whatever that might be ;)
		//  Check out the THREE.VRController.supported{} object to see
		//  all the named buttons we’ve already mapped for you!
		controller.addEventListener( 'primary press began', function( event ){
			event.target.userData.mesh.material.color.setHex( meshColorOn )
			//guiInputHelper.pressed( true );
			console.log("controller is pressed");

			// check if you're clicking a ball
			if(intersects.length > 0){
				INTERSECTED = intersects[ 0 ].object;
				if(isBallClicked){	// if a ball IS attached, SEND TO BACK
					camera.remove(INTERSECTED);
					scene.add(INTERSECTED);

					INTERSECTED.position.x = Math.random() * 4 - 2;
					INTERSECTED.position.y = Math.random() * 4 - 2;
					INTERSECTED.position.z = Math.random() * 4 - 2;

					// let PercentX = 50;
					// let PercentY = 50;
					// let PositionX = (PercentX / 100) * 2 - 1;
					// let PositionY = (PercentY / 100) * 2 - 1;

					// INTERSECTED.position.x = PositionX * camera.aspect;
					// INTERSECTED.position.y = PositionY;

					// INTERSECTED.position.z = Math.random() * 4;
					// INTERSECTED.rotation.y = Math.random() * Math.PI;
				} else if(!isBallClicked) { // if there are no attached balls, ATTACH IT
					INTERSECTED = intersects[ 0 ].object;
					//INTERSECTED.remove(INTERSECTED.userData.physicsBody); 
					scene.remove(INTERSECTED);
					camera.add(INTERSECTED);

					let PercentX = 50;
					let PercentY = 50;
					let PositionX = (PercentX / 100) * 2 - 1;
					let PositionY = (PercentY / 100) * 2 - 1;

					INTERSECTED.position.x = PositionX * camera.aspect;
					INTERSECTED.position.y = PositionY;

					INTERSECTED.position.z = -1;
					//INTERSECTED.rotation.y += 0.01; 
				}
				isBallClicked = !isBallClicked;
			}
		})
		controller.addEventListener( 'primary press ended', function( event ){
			event.target.userData.mesh.material.color.setHex( meshColorOff )
			console.log("controller has ended");
		})

		//  Daddy, what happens when we die?
		controller.addEventListener( 'disconnected', function( event ){
			controller.parent.remove( controller )
		})
})
	function update(){
		window.requestAnimationFrame(animate);
	}

	let fps = 30; 

	function animate(timestamp) {
		//var timer = 0.0001 * Date.now();
		// let delta = Math.min(timestamp - lastRenderTime, 500);
		// var delta2 = clock.getDelta() * 60;
		var deltaTime = clock.getDelta();
	    //lastRenderTime = timestamp;
	    //light.position.x = 10 * Math.cos( timer );
	    frontRefractor.material.uniforms.time.value += deltaTime;
	    leftRefractor.material.uniforms.time.value += deltaTime;
	    rightRefractor.material.uniforms.time.value += deltaTime;
	    bottomRefractor.material.uniforms.time.value += deltaTime;
	    backRefractor.material.uniforms.time.value += deltaTime;
	    topRefractor.material.uniforms.time.value += deltaTime;

	    arrow.setDirection(raycaster.ray.direction);
 
		// update the raycaster
		raycaster.set(camera.getWorldPosition(), camera.getWorldDirection());
		 
		// intersect with all scene meshes.
		intersects = raycaster.intersectObjects(spheres);
		
		if ( intersects.length > 0) {
			// Ball highlighting
			if ( INTERSECTED != intersects[ 0 ].object & isBallClicked == false ) {
				//console.log("raycaster has intersected");
				INTERSECTED = intersects[ 0 ].object;
				let sisterKey = INTERSECTED.userData.sister; 
				for (let i=0;i<spheres.length;i++){
					if (spheres[i] != INTERSECTED & spheres[i].userData.sister == sisterKey){
						INTERSECTED2 = spheres[i];
					}
				}
				
				//console.log(INTERSECTED);	
				//console.log(INTERSECTED2);

				INTERSECTED.scale.set(1.3, 1.3, 1.3);
				INTERSECTED2.scale.set(1.3, 1.3, 1.3);

			}  
			// attach selected ball to camera
			if (INTERSECTED != null & INTERSECTED2 != null & isBallClicked == true) {
				INTERSECTED.rotation.y += 0.001;
				INTERSECTED2.rotation.y += 0.001;
			}

		} else {
			for(let i=0;i<spheres.length;i++){
				spheres[i].scale.set(1, 1, 1);
			}
			INTERSECTED = null;
			INTERSECTED2 = null; 
		}

		updatePhysics( deltaTime );
		
		if(vrDisplay.isPresenting) {
			setTimeout(function(){
			   	controls.update();
			   	orbitControls.update();
			   	THREE.VRController.update();
			   	effect.render(scene, camera);
			   	vrDisplay.requestAnimationFrame(animate);
			},1000 / fps); 
		} else {
			controls.update();
			orbitControls.update();
	    	renderer.render(scene, camera);
	    	window.requestAnimationFrame(animate);
		}
		//time += deltaTime;
	}

	function updatePhysics( deltaTime ) {
		//console.log("I am updating");
		physicsWorld.stepSimulation( deltaTime, 10 );
		// Update objects
		for ( let i = 0, il = dynamicObjects.length; i < il; i++ ) {
			let objThree = dynamicObjects[ i ];
			//let vec = new Ammo.btVector3( THREE.Math.randInt(-5,20),THREE.Math.randInt(-20,20),THREE.Math.randInt(-20,20) );
			let vec = new Ammo.btVector3(1,1,1);
			objThree.userData.physicsBody.setAngularVelocity( vec );
			//objThree.userData.physicsBody.setLinearVelocity( vec );
			var objPhys = objThree.userData.physicsBody;
			var ms = objPhys.getMotionState();
			if ( ms ) {
				ms.getWorldTransform( transformAux1 );
				let p = transformAux1.getOrigin();
				let q = transformAux1.getRotation();
				objThree.position.set( p.x(), p.y(), p.z() );
				//objThree.quaternion.set( q.x(), q.y(), q.z(), q.w() );
			}
		}
	}
	window.addEventListener('mousemove', onMouseMove, false );
	window.addEventListener("click", function(){
		console.log("I am pressed");
		//var requestFullScreen = elem.requestFullscreen || elem.msRequestFullscreen || elem.mozRequestFullScreen || elem.webkitRequestFullscreen;
		//document.body.webkitRequestFullscreen();
    	if(intersects.length > 0) {
			INTERSECTED = intersects[ 0 ].object;
			let sisterKey = INTERSECTED.userData.sister; 
			for (let i=0;i<spheres.length;i++){
				if (spheres[i] != INTERSECTED & spheres[i].userData.sister == sisterKey){
						INTERSECTED2 = spheres[i];
				}
			}
			if(isBallClicked){	// if a ball IS attached, SEND TO BACK
				//camera.remove(INTERSECTED);
				THREE.SceneUtils.detach( INTERSECTED, camera , scene );
				scene.add(INTERSECTED);

				//camera.remove(INTERSECTED2);
				THREE.SceneUtils.detach( INTERSECTED2, camera, scene );
				scene.add(INTERSECTED2);

				let xVal = Math.random() * 4 - 2;
				let yVal = Math.random() * 4 - 2;
				let zVal = Math.random() * 4 - 2;

				INTERSECTED.position.x = xVal;
				INTERSECTED.position.y = yVal;
				INTERSECTED.position.z = zVal;

				INTERSECTED2.position.x = xVal;
				INTERSECTED2.position.y = yVal;
				INTERSECTED2.position.z = zVal;

			} else if(!isBallClicked) { 
				INTERSECTED = intersects[ 0 ].object;
				let sisterKey = INTERSECTED.userData.sister; 
				for (let i=0;i<spheres.length;i++){
					if (spheres[i] != INTERSECTED & spheres[i].userData.sister == sisterKey){
						INTERSECTED2 = spheres[i];
					}
				}
				 
				//scene.remove(INTERSECTED);
				THREE.SceneUtils.attach( INTERSECTED, scene, camera );
				//camera.add(INTERSECTED);

				//scene.remove(INTERSECTED2);
				THREE.SceneUtils.attach( INTERSECTED2, scene, camera );
				//camera.add(INTERSECTED2);

				let PercentX = 50;
				let PercentY = 50;
				let PositionX = (PercentX / 100) * 2 - 1;
				let PositionY = (PercentY / 100) * 2 - 1;

				INTERSECTED.position.x = PositionX;
				INTERSECTED.position.y = PositionY;
				INTERSECTED.position.z = 0;

				INTERSECTED2.position.x = PositionX;
				INTERSECTED2.position.y = PositionY;
				INTERSECTED2.position.z = 0;
			}
			isBallClicked = !isBallClicked;
		}
	});

	</script>
</html>
